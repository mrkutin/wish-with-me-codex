name: Deploy to Ubuntu (Main App)

# This workflow deploys the main application to Ubuntu server (176.106.144.182)
# Services: nginx, frontend, core-api-1, core-api-2, item-resolver-1, item-resolver-2, couchdb
# Domain: wishwith.me
#
# Trigger: Automatic on push to main, or manual via workflow_dispatch

on:
  push:
    branches:
      - main
    paths:
      - 'services/frontend/**'
      - 'services/core-api/**'
      - 'services/item-resolver/**'
      - 'docker-compose.yml'
      - 'nginx/**'
  workflow_dispatch:

env:
  SERVER_HOST: 176.106.144.182  # Ubuntu server
  SERVER_USER: mrkutin
  DEPLOY_PATH: /home/mrkutin/wish-with-me-codex

jobs:
  detect-changes:
    name: Detect Changed Services
    runs-on: ubuntu-latest
    outputs:
      frontend: ${{ steps.changes.outputs.frontend }}
      core-api: ${{ steps.changes.outputs.core-api }}
      item-resolver: ${{ steps.changes.outputs.item-resolver }}
      infrastructure: ${{ steps.changes.outputs.infrastructure }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Detect changes
        id: changes
        run: |
          # Get list of changed files
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            # Manual trigger - deploy everything
            echo "frontend=true" >> $GITHUB_OUTPUT
            echo "core-api=true" >> $GITHUB_OUTPUT
            echo "item-resolver=true" >> $GITHUB_OUTPUT
            echo "infrastructure=true" >> $GITHUB_OUTPUT
          else
            # Auto trigger - detect changes
            CHANGED_FILES=$(git diff --name-only HEAD^ HEAD)

            echo "Changed files:"
            echo "$CHANGED_FILES"

            # Check each service
            if echo "$CHANGED_FILES" | grep -q "services/frontend/"; then
              echo "frontend=true" >> $GITHUB_OUTPUT
            else
              echo "frontend=false" >> $GITHUB_OUTPUT
            fi

            if echo "$CHANGED_FILES" | grep -q "services/core-api/"; then
              echo "core-api=true" >> $GITHUB_OUTPUT
            else
              echo "core-api=false" >> $GITHUB_OUTPUT
            fi

            if echo "$CHANGED_FILES" | grep -q "services/item-resolver/"; then
              echo "item-resolver=true" >> $GITHUB_OUTPUT
            else
              echo "item-resolver=false" >> $GITHUB_OUTPUT
            fi

            # Check infrastructure files
            if echo "$CHANGED_FILES" | grep -qE "(docker-compose\.yml|nginx/)"; then
              echo "infrastructure=true" >> $GITHUB_OUTPUT
            else
              echo "infrastructure=false" >> $GITHUB_OUTPUT
            fi
          fi

  test-frontend:
    name: Test Frontend
    needs: detect-changes
    runs-on: ubuntu-latest
    if: needs.detect-changes.outputs.frontend == 'true'
    defaults:
      run:
        working-directory: services/frontend

    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: services/frontend/package-lock.json

      - name: Install dependencies
        run: npm ci

      - name: Run unit tests
        run: npm run test:unit -- --run

      - name: Run type check
        run: npm run typecheck

  test-core-api:
    name: Test Core API
    needs: detect-changes
    runs-on: ubuntu-latest
    if: needs.detect-changes.outputs.core-api == 'true'
    defaults:
      run:
        working-directory: services/core-api

    steps:
      - uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'
          cache: 'pip'
          cache-dependency-path: services/core-api/requirements.txt

      - name: Install dependencies
        run: pip install -r requirements.txt

      - name: Run tests
        run: pytest tests/ -v --tb=short

  test-item-resolver:
    name: Test Item Resolver
    needs: detect-changes
    runs-on: ubuntu-latest
    if: needs.detect-changes.outputs.item-resolver == 'true'
    defaults:
      run:
        working-directory: services/item-resolver

    steps:
      - uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'
          cache: 'pip'
          cache-dependency-path: services/item-resolver/requirements.txt

      - name: Install dependencies
        run: pip install -r requirements.txt

      - name: Run tests
        run: pytest tests/ -v --tb=short

  deploy:
    name: Deploy to Ubuntu Server
    needs: [detect-changes, test-frontend, test-core-api, test-item-resolver]
    runs-on: ubuntu-latest
    # Only run if at least one service or infrastructure changed AND tests passed
    # Use always() to evaluate even if test jobs were skipped
    if: |
      always() &&
      (needs.detect-changes.outputs.frontend == 'true' ||
       needs.detect-changes.outputs.core-api == 'true' ||
       needs.detect-changes.outputs.item-resolver == 'true' ||
       needs.detect-changes.outputs.infrastructure == 'true') &&
      (needs.test-frontend.result == 'success' || needs.test-frontend.result == 'skipped') &&
      (needs.test-core-api.result == 'success' || needs.test-core-api.result == 'skipped') &&
      (needs.test-item-resolver.result == 'success' || needs.test-item-resolver.result == 'skipped')

    steps:
      - name: Setup SSH agent
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY_UBUNTU }}

      - name: Add server to known_hosts
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -H ${{ env.SERVER_HOST }} >> ~/.ssh/known_hosts

      - name: Display deployment plan
        run: |
          echo "=== Deployment Plan (Ubuntu Server) ==="
          echo "Frontend: ${{ needs.detect-changes.outputs.frontend }}"
          echo "Core API: ${{ needs.detect-changes.outputs.core-api }}"
          echo "Item Resolver: ${{ needs.detect-changes.outputs.item-resolver }}"
          echo "Infrastructure: ${{ needs.detect-changes.outputs.infrastructure }}"

      - name: Pull latest code
        run: |
          ssh ${{ env.SERVER_USER }}@${{ env.SERVER_HOST }} << 'ENDSSH'
            set -e
            cd ${{ env.DEPLOY_PATH }}

            echo "=== Pulling latest code ==="

            # Store current commit as last known-good for rollback
            CURRENT_COMMIT=$(git rev-parse HEAD)
            echo "$CURRENT_COMMIT" > .last-known-good-commit
            echo "Saved rollback point: $CURRENT_COMMIT"

            git fetch origin
            git reset --hard origin/main

            echo "Current commit: $(git log -1 --oneline)"
          ENDSSH

      - name: Deploy services
        run: |
          ssh ${{ env.SERVER_USER }}@${{ env.SERVER_HOST }} << 'ENDSSH'
            set -e
            cd ${{ env.DEPLOY_PATH }}

            # Ensure .env file exists
            if [ ! -f .env ]; then
              echo "ERROR: .env file not found!"
              echo "Please create .env file on server with production secrets"
              exit 1
            fi

            # Ensure data directories exist
            mkdir -p /home/mrkutin/wishwithme-data/couchdb

            # Fix network label mismatch (from docker compose v1 to v2 migration)
            if docker network inspect wishwithme-network >/dev/null 2>&1; then
              echo "=== Checking Docker network compatibility ==="
              NETWORK_LABEL=$(docker network inspect wishwithme-network --format '{{index .Labels "com.docker.compose.network"}}' 2>/dev/null || echo "")
              if [ "$NETWORK_LABEL" != "wishwithme" ] && [ -n "$NETWORK_LABEL" ]; then
                echo "Network label mismatch detected (label: '$NETWORK_LABEL'), recreating network..."
                for container in $(docker network inspect wishwithme-network -f '{{range .Containers}}{{.Name}} {{end}}' 2>/dev/null); do
                  echo "Stopping container: $container"
                  docker stop "$container" 2>/dev/null || true
                  docker rm "$container" 2>/dev/null || true
                done
                docker network rm wishwithme-network || true
                echo "Network removed, will be recreated on next up"
              fi
            fi

            # Build changed services
            # IMPORTANT: Always rebuild frontend when it changes OR when core-api changes
            # to ensure frontend uses latest API types/contracts
            REBUILD_SERVICES=""

            FRONTEND_CHANGED="${{ needs.detect-changes.outputs.frontend }}"
            CORE_API_CHANGED="${{ needs.detect-changes.outputs.core-api }}"

            # Rebuild frontend if it changed OR if core-api changed (API contract updates)
            if [ "$FRONTEND_CHANGED" == "true" ] || [ "$CORE_API_CHANGED" == "true" ]; then
              REBUILD_SERVICES="$REBUILD_SERVICES frontend"
            fi

            if [ "$CORE_API_CHANGED" == "true" ]; then
              REBUILD_SERVICES="$REBUILD_SERVICES core-api-1 core-api-2"
            fi

            if [ "${{ needs.detect-changes.outputs.item-resolver }}" == "true" ]; then
              REBUILD_SERVICES="$REBUILD_SERVICES item-resolver-1 item-resolver-2"
            fi

            # If infrastructure changed, rebuild nginx
            if [ "${{ needs.detect-changes.outputs.infrastructure }}" == "true" ]; then
              REBUILD_SERVICES="$REBUILD_SERVICES nginx"
            fi

            echo "=== Building services: $REBUILD_SERVICES ==="

            if [ -n "$REBUILD_SERVICES" ]; then
              # Build the changed services (no-cache to ensure fresh build)
              docker compose -f docker-compose.yml build --no-cache $REBUILD_SERVICES

              # Restart the changed services (force-recreate to ensure new containers)
              echo "=== Restarting services: $REBUILD_SERVICES ==="
              docker compose -f docker-compose.yml up -d --no-deps --force-recreate $REBUILD_SERVICES
            else
              echo "No services to rebuild"
            fi

            # Ensure all services are up
            docker compose -f docker-compose.yml up -d

            # Cleanup old images
            echo "=== Cleaning up old images ==="
            docker image prune -f
          ENDSSH

      - name: Wait for services to start
        run: |
          echo "Waiting 20 seconds for services to start..."
          sleep 20

      - name: Health check
        run: |
          ssh ${{ env.SERVER_USER }}@${{ env.SERVER_HOST }} << 'ENDSSH'
            set -e
            cd ${{ env.DEPLOY_PATH }}

            echo "=== Health Check ==="

            # Check that containers are running
            docker compose -f docker-compose.yml ps

            # Test core-api health endpoints (internal)
            if [ "${{ needs.detect-changes.outputs.core-api }}" == "true" ]; then
              echo "Checking core-api-1 health..."
              docker exec wishwithme-core-api-1 python -c "import httpx; httpx.get('http://localhost:8000/live', timeout=5)" && echo "✓ Core API 1 is healthy" || (echo "✗ Core API 1 health check failed" && exit 1)
              echo "Checking core-api-2 health..."
              docker exec wishwithme-core-api-2 python -c "import httpx; httpx.get('http://localhost:8000/live', timeout=5)" && echo "✓ Core API 2 is healthy" || (echo "✗ Core API 2 health check failed" && exit 1)
            fi

            # Test frontend (internal) - use IPv4 explicitly
            if [ "${{ needs.detect-changes.outputs.frontend }}" == "true" ]; then
              echo "Checking frontend..."
              docker exec wishwithme-frontend wget --no-verbose --tries=1 --spider http://127.0.0.1/ && echo "✓ Frontend is healthy" || (echo "✗ Frontend health check failed" && exit 1)
            fi

            # Test item-resolver health endpoints (internal)
            if [ "${{ needs.detect-changes.outputs.item-resolver }}" == "true" ]; then
              echo "Checking item-resolver-1 health..."
              docker exec wishwithme-item-resolver-1 wget --no-verbose --tries=1 -O- --timeout=5 --header="Authorization: Bearer ${RU_BEARER_TOKEN:-ru_secret}" http://127.0.0.1:8000/healthz > /dev/null && echo "✓ Item Resolver 1 is healthy" || (echo "✗ Item Resolver 1 health check failed" && exit 1)
              echo "Checking item-resolver-2 health..."
              docker exec wishwithme-item-resolver-2 wget --no-verbose --tries=1 -O- --timeout=5 --header="Authorization: Bearer ${RU_BEARER_TOKEN:-ru_secret}" http://127.0.0.1:8000/healthz > /dev/null && echo "✓ Item Resolver 2 is healthy" || (echo "✗ Item Resolver 2 health check failed" && exit 1)
            fi

            echo "=== All health checks passed ==="
          ENDSSH

      - name: Verify external access
        if: needs.detect-changes.outputs.infrastructure == 'true'
        continue-on-error: true  # Don't fail deployment if nginx/external access isn't available
        run: |
          echo "Testing external access through nginx..."
          echo "Note: This check is informational - nginx may not be configured yet"

          # Test HTTP endpoint (allow curl failures gracefully)
          HTTP_RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" --connect-timeout 5 http://${{ env.SERVER_HOST }}/health 2>/dev/null || echo "000")
          if [ "$HTTP_RESPONSE" == "200" ] || [ "$HTTP_RESPONSE" == "301" ]; then
            echo "✓ HTTP endpoint responding (status: $HTTP_RESPONSE)"
          elif [ "$HTTP_RESPONSE" == "000" ]; then
            echo "⚠ External access not available (nginx may not be running or SSL not configured)"
          else
            echo "⚠ HTTP endpoint returned unexpected status: $HTTP_RESPONSE"
          fi

      - name: Deployment summary
        if: always()
        run: |
          ssh ${{ env.SERVER_USER }}@${{ env.SERVER_HOST }} << 'ENDSSH'
            cd ${{ env.DEPLOY_PATH }}

            echo "=== Deployment Summary (Ubuntu) ==="
            echo "Deployed commit: $(git log -1 --oneline)"
            echo ""
            echo "Running containers:"
            docker compose -f docker-compose.yml ps
          ENDSSH

  rollback:
    name: Rollback on Failure
    needs: [detect-changes, deploy]
    runs-on: ubuntu-latest
    if: failure()

    steps:
      - name: Setup SSH agent
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY_UBUNTU }}

      - name: Add server to known_hosts
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -H ${{ env.SERVER_HOST }} >> ~/.ssh/known_hosts

      - name: Rollback deployment
        run: |
          ssh ${{ env.SERVER_USER }}@${{ env.SERVER_HOST }} << 'ENDSSH'
            set -e
            cd ${{ env.DEPLOY_PATH }}

            echo "=== DEPLOYMENT FAILED - ROLLING BACK ==="

            # Fix network label mismatch if present
            if docker network inspect wishwithme-network >/dev/null 2>&1; then
              NETWORK_LABEL=$(docker network inspect wishwithme-network --format '{{index .Labels "com.docker.compose.network"}}' 2>/dev/null || echo "")
              if [ "$NETWORK_LABEL" != "wishwithme" ] && [ -n "$NETWORK_LABEL" ]; then
                echo "Network label mismatch detected (label: '$NETWORK_LABEL'), recreating network..."
                for container in $(docker network inspect wishwithme-network -f '{{range .Containers}}{{.Name}} {{end}}' 2>/dev/null); do
                  echo "Stopping container: $container"
                  docker stop "$container" 2>/dev/null || true
                  docker rm "$container" 2>/dev/null || true
                done
                docker network rm wishwithme-network || true
              fi
            fi

            # Check if we have a saved rollback point
            if [ -f .last-known-good-commit ]; then
              ROLLBACK_COMMIT=$(cat .last-known-good-commit)
              echo "Rolling back to last known-good commit: $ROLLBACK_COMMIT"
              git reset --hard "$ROLLBACK_COMMIT"
            else
              echo "WARNING: No rollback point found, using HEAD~1"
              git reset --hard HEAD~1
            fi

            echo "Rolled back to commit: $(git log -1 --oneline)"

            # Rebuild and restart failed services
            REBUILD_SERVICES=""

            if [ "${{ needs.detect-changes.outputs.frontend }}" == "true" ]; then
              REBUILD_SERVICES="$REBUILD_SERVICES frontend"
            fi

            if [ "${{ needs.detect-changes.outputs.core-api }}" == "true" ]; then
              REBUILD_SERVICES="$REBUILD_SERVICES core-api-1 core-api-2"
            fi

            if [ "${{ needs.detect-changes.outputs.item-resolver }}" == "true" ]; then
              REBUILD_SERVICES="$REBUILD_SERVICES item-resolver-1 item-resolver-2"
            fi

            if [ "${{ needs.detect-changes.outputs.infrastructure }}" == "true" ]; then
              REBUILD_SERVICES="$REBUILD_SERVICES nginx"
            fi

            echo "Rebuilding previous versions: $REBUILD_SERVICES"
            docker compose -f docker-compose.yml build $REBUILD_SERVICES
            docker compose -f docker-compose.yml up -d --no-deps $REBUILD_SERVICES

            echo "=== Rollback complete ==="
            echo "Restored to commit: $(git log -1 --oneline)"
          ENDSSH
